#include <iostream>

using namespace std;

void table();
void number(int &n);
int & Mod2_0(int Numbers[],int y);

int main(){
	//Αλλαγή τιμής από const.
	const double num = 21.39;
	double *p;
	p = (double *) &num;
	*p = 00.68;
	cout << "Δεν έχει αλλάξει είναι ακόμα: " << num << endl;
	table();
	//
	int y, n;
	cout << "Δώσε νούμερο για να πολλαπλασιαστεί με το 3: " << endl;
	cin >> n;
	cout << "Πόσες φορές θες να πολλαπλασιαστεί με το 3; " << endl;
	cin >> y;
	int Numbers[y+1] = {};
	for(int i = 0;i < y;i++){
		number(n);
		Numbers[i] = n;
	}
	Numbers[y+1] = 0;
	int & Mod2 = Mod2_0(Numbers,y);
	cout << "Ο μεγαλύτερος αριθμός του πίνακα: " << n << endl;
	if (Mod2 != 0)
		cout << "Ο μεγαλύτερος αριθμός που μπορεί να διαιρεθεί με το 2 είναι: " << Mod2 << endl;
	else
		cout << "Κανένας από τους νέους αριθμούς δεν μπορεί να διαιρεθεί με το 2 και να έχει υπόλοιπο 0." << endl;




}
/*Όταν χρησιμοποιούμε "const" ο compiler οπουδήποτε υπάρχει το όνομα της μεταβλητής που είναι const, θα βάλει εξαρχής την τιμή της μεταβλητής χωρίς να κάνει περαιτέρω πράξεις.
Για αυτό ακόμα και αν αλλάζουμε την τιμή με την βοήθεια pointer ο compiler θα συνεχίσει να τυπώνει την αρχική τιμή της μεταβλητής που ορίσαμε ως const.*/

//Χρήση new, new[], delete, delete[].
void table(){
	int *p;
	p= new int;
	*p = 20;
	cout << *p << endl;
	delete p;
	int *z, y;
	z = new int[8];
	for(int i=0;i<8;i++){
		cout << "Δώσε αριθμό για τη " << i << " θέση του πίνακα." << endl;
		cin >> z[i];
	}
	cout << "Από ποιά θέση του πίνακα θέλεις να εκτυπώσεις το περιεχόμενο;" << endl;
	do{
	cin >> y;
	}while(y < 0 || y > 7);
	cout << z[y] << endl;
	delete z;
//Το delete απελευθερώνει την μνήμη που δεσμεύσαμε προηγουμένως.
}

void number(int &n){
	n *= 3;
}

int & Mod2_0(int Numbers[], int y){
	int result = -1;
	for(int i = 0;i < y;i++){
		if(Numbers[i]%2==0)
			result = i;
	}
	if(result != -1)
		return Numbers[result];
	else
		return Numbers[y+1];
}
